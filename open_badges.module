<?php

/**
 * @file
 * @brief Open Badges module file
 *
 * This file contains all the hook implementations and commonly used functions
 *
 * @author Jeff Robbins (jjeff), http://drupal.org/user/17190
 * @author Chad Phillips (hunmonk), http://drupal.org/user/22079
 * @author Heine Deelstra (Heine), http://drupal.org/user/17943
 * @author Nuno Veloso (nunoveloso18), http://drupal.org/user/80656
 * @author Richard Skinner (Likeless), http://drupal.org/user/310635
 * @author Nancy Wichmann (NancyDru), http://drupal.org/user/101412
 *
 */

/**
 * Implements hook_help().
 */
function open_badges_help($path, $arg) {
  global $user;
  switch ($path) {
    case 'admin/modules#description':

    case 'admin/user/open_badges':
      return t('User badges are iconic images which can be assigned to users. They can represent accomplishments, status, or anything you\'d like. These badges will show up in the user\'s profile, and could also be used by a theme to appear with user postings on forums, comments, or nodes. Badges can be assigned manually by an administrator by visiting a user\'s profile. They also can be assigned automatically by role or ecommerce purchase (if ecommerce modules are installed). The excellent !link module can also be used to set and unset badges on a wide variety of conditions.', array('!link' => l('Rules', 'http://drupal.org/project/rules', array('absolute' => TRUE))));

    case 'admin/user/open_badges/roles':
      return t("Select the badge that you'd like to associate with each role.");

    case 'admin/user/open_badges/images':
      return t("This is the open badges image library. Note that this area is not functional if you have private download active. Here you can upload images to display as a open badge, but you can also enter image URLs directly in the badge form, so this area is optional. The images can be anything you like, but it is recommended that you maintain a uniform icon size for all of your badges. Keep in mind that a user may have many badges displayed so you'll probably want to keep them as small as possible (like 16x16 pixels or smaller).");

    case 'user/%/badges':
    case 'user/%/badges/list':
      $showone = variable_get('open_badges_showone', 0);
      if (variable_get('open_badges_userweight', 0) && ($user->uid == $arg[1] || user_access('change badge assignments')) ) {
        // Help messages for users who can reorder.
        if ($showone) {
          return t("You can reorder badges here. Some badges may not appear on the list; these badges cannot be reordered. Only the top !number badges will be shown publicly.", array('!number' => $showone));
        }
        else {
          return t("You can reorder your badges here. Some badges may not appear on the list; these badges cannot be reordered.");
        }
      }
      else {
        // Either we don't support reordering, or this user lacks the permission to do it.
//        return t("These are all the badges owned by this user.");
      }

  }
}

/**
 * Implements hook_perm().
 */
function open_badges_perm() {
  return array(
    'manage badges',
    'change badge assignments',
    'show badges in user profile'
  );
}

/**
 * Implements hook_menu().
 */
function open_badges_menu() {
  $items = array();
  $access = array('manage badges');

  $items['admin/user/open_badges'] = array(
    'title' => 'Badges',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_badgelist_form'),
    'access arguments' => $access,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/list'] = array(
    'title' => 'List',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_badgelist_form'),
    'access arguments' => $access,
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/add'] = array(
    'title' => 'Add',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_edit_form'),
    'access arguments' => $access,
    'type' => MENU_LOCAL_TASK,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/images'] = array(
    'title' => 'Images',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_images_form'),
    'access arguments' => $access,
    'type' => MENU_LOCAL_TASK,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/roles'] = array(
    'title' => 'Roles',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_roles_form'),
    'access arguments' => $access,
    'type' => MENU_LOCAL_TASK,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_settings_form'),
    'access arguments' => $access,
    'type' => MENU_LOCAL_TASK,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/edit/%'] = array(
    'title' => 'Edit badge',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_edit_form', 4),
    'access arguments' => $access,
    'type' => MENU_CALLBACK,
    'file' => 'open_badges.admin.inc',
    );

  $items['admin/user/open_badges/delete/%'] = array(
    'title' => 'Delete badge',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('open_badges_delete_form', 4),
    'access arguments' => $access,
    'type' => MENU_CALLBACK,
    'file' => 'open_badges.admin.inc',
    );

  $items['user/%/badges'] = array(
    'title' => 'Badges',
    'page callback' => 'open_badges_userweight_page',
    'page arguments' => array(1),
    'access arguments' => array('show badges in user profile'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
    );

  $items['user/%/badges/list'] = array(
    'title' => 'List',
    'page callback' => 'open_badges_userweight_page',
    'page arguments' => array(1),
    'access arguments' => array('show badges in user profile'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    );

  $items['user/%/badges/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'open_badges_page',
    'page arguments' => array(1),
    'access arguments' => array('change badge assignments'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
    );

  $items['open_badges/autocomplete'] = array(
    'title' => 'Open Badges Badge Name Autocomplete',
    'page callback' => 'open_badges_badge_autocomplete',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    );

  return $items;
}

/**
 * Implements hook_user().
 *
 * This handles assignment of badges based on role.
 * When a role is assigned or removed, appropriate badges are added or removed.
 */
function open_badges_user($op, &$edit, &$account, $category = 'account') {
  global $user;
  static $badges = array();
  static $badges_all = array();

  //dpm("open_badges_user: op: '{$op}' category: '{$category}'");
  switch ($op) {
    case 'load':
      // Have we loaded this user before?
      // If so, return both cached values (full and limited lists)
      if (isset($badges[$account->uid])) {
        //dpm("open_badges_user: setting account->badges to cached value");
        $account->badges = $badges[$account->uid];
        $account->badges_all = $badges_all[$account->uid];
        break;
      }

      $account->badges = array();

      if ($account->uid > 0) {
        // Get all open badges for this user, regardless of whether we filter the ones we show.
        //dpm("open_badges_user: getting all badges for user '{$account->uid}'");
        $account->badges_all = open_badges_get_badges($account->uid, array('nolimit' => TRUE));

        // Now make the array of badges we will show.
        $account->badges = $account->badges_all;
        if ($limit = variable_get('open_badges_showone', 0)) {
          //dpm("open_badges_user: limiting what will be shown");
//  dsm("Limit: $limit, account->badges: ".print_r($account->badges, true));
          // Loop through all potential badges and get the ones we can show.
          foreach ($account->badges_all as $bid => $badge) {
            $badge->class = 'badge ' . _open_badges_class($badge);
            // Display the badge if there's no limit or if the badge is unhideable or if we are within our limit.
            if ($limit > 0 || $badge->unhideable == 1) {
              $account->badges[$bid] = $badge;
              // Count down our limit, unless the badge doesn't count towards it.
              if (!$badge->doesnotcounttolimit) {
                $limit--;
              }
            }
          }
        }
      }

      // Cache both lists (the full list and the limited list)
      $badges_all[$account->uid] = $account->badges_all;
      $badges[$account->uid] = $account->badges;
      break;

    case 'insert':
      if (is_array($account->roles)) {
        // Get the list of role badges.
        $roles = open_badges_get_roles();
        $badges = open_badges_get_badges('select');
        $message = user_access('manage badges');
        $rids = array_keys($account->roles);
        foreach ($rids as $rid) {
          // If this role has a badge...
          if (key_exists($rid, $roles)) {
            // and user doesn't already have this badge.
            if (!key_exists($roles[$rid], $account->badges)) {
              $success = open_badges_user_add_badge($account->uid, $roles[$rid], 'role');
              if ($success && $message) {
                drupal_set_message(t('User assigned %name badge.', array('%name' => $badges[$roles[$rid]])));
              }
            }
          }
        }
      }
      break;

    case 'update':
      if (is_array($edit['roles'])) {
        // Badges only get assigned or removed when a user's role assignments are changed.

        // Add authenticated users (code below only cares about array keys) to prevent badge deletion
        $new_roles = $edit['roles'];
        $new_roles[2] = 2;
        // Get the list of role badges.
        $roles = open_badges_get_roles();
        $badges = open_badges_get_badges('select');

        $message = user_access('manage badges');

        // What are the added roles?
        $added = array_diff(array_keys($new_roles), array_keys((array)$account->roles));
        foreach ($added as $rid) {
          // if this role has a badge
          if (key_exists($rid, $roles) && !key_exists($roles[$rid], $account->badges_all)) {
            $success = open_badges_user_add_badge($account->uid, $roles[$rid], 'role');
            if ($success && $message) {
              drupal_set_message(t('User assigned %name badge.', array('%name' => $badges[$roles[$rid]])));
            }
          }
        }

        // What are the removed roles?
        $removed = array_diff(array_keys((array)$account->roles), array_keys($new_roles));
        foreach ($removed as $rid) {
          // If this role has a badge and user has this badge..
          if (key_exists($rid, $roles) && key_exists($roles[$rid], $account->badges_all)) {
            $success = open_badges_user_remove_badge($account->uid, $roles[$rid], 'role');
            drupal_set_message(t('%name badge removed from user.', array('%name' => $badges[$roles[$rid]])));
          }
        }

        //As we may have altered the badges, we need to refresh them in the $account object
        $account->badges = open_badges_get_badges($account->uid);
        $account->badges_all = open_badges_get_badges($account->uid, array('nolimit' => TRUE));
      }
      break;

    case 'delete':
      db_query('DELETE FROM {open_badges_user} WHERE uid = %d', $account->uid);
      break;

    case 'view':
      // dpm("open_badges_user: doing 'view' probably calling theme for open_badge and open_badge_group");
      // dsm($account, FALSE, "The account in open_badges_user");
      if (is_array($account->badges) && count($account->badges)) {
        $badgeimgs = array();
        foreach ($account->badges as $badge) {
          $badgeimgs[] = theme('open_badge', $badge, $account);
        }
        $account->content['open_badges'] = array(
          '#type' => 'user_profile_category',
          '#title' => t('Badges'),
          '#weight' => 10,
          '#attributes' => array('class' => 'open-badges'),
        );
        $account->content['open_badges']['badges'] = array(
          '#type' => 'user_profile_item',
          '#value' => theme('open_badge_group', $badgeimgs),
          '#attributes' => array('class' => 'badges'),
        );
      }
  }
}

/**
 * Helper function for building badge class names.
 * I was originally using form_clean_id, but it is not secure.
 *
 * @param $badge - the object describing the badge.
 * @return string containing the class name.
 */
function _open_badges_class($badge) {
  // Doing separate lines makes changing the algorithm easier.
  $class = $badge->name;
  $class = strip_tags($class, '');
  $class = drupal_strtolower($class);
  $class = str_replace(array('"', "'"), '', $class);
  $class = str_replace(array('_', ' '), '-', $class);

  // dsm("_open_badges_class: badge->name = $badge->name becomes $class.");
  return $class;
}

/**
 * Implements hook_theme().
 */
function open_badges_theme() {
  return array(
    'open_badge' => array(
      'arguments' => array('badge' => NULL, 'account' => NULL),
    ),
    'open_badge_group' => array(
      'arguments' => array('badgeimages' => array()),
    ),
    'open_badges_userweight_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'open_badges_badgelist_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'open_badges_change_form_theme' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * form for users to weight their own badges
 */
function open_badges_userweight_form($form_state, $account) {
  $allbadges = $account->badges_all;

  // Header row for the badge reweighting list.
  $form['header'] = array('#type' => 'value', '#value' => array(
    array('data' => t('Name')),
    array('data' => t('Badge')),
    array('data' => t('Weight')),
  ));

  // We need to know what the weight delta will be, which depends on the number
  // of badges we will list.
  foreach ($allbadges as $badge) {
    if (!$badge->fixedweight) {
      $delta++;
    }
  }

  // Build a table listing the appropriate badges.
  foreach ($allbadges as $badge) {
    // We cannot include fixed weight badges.
    if ($badge->fixedweight) {
      continue;
    }

    // Set the badge default weight.
    $weight = $badge->weight;
    if (isset($badge->userweight)) {
      $weight = $badge->userweight;
    }

    $form['name'][$badge->bid] = array('#value' => check_plain($badge->name));
    $form['badge'][$badge->bid] = array('#value' => theme('open_badge', $badge, $account));

    $form['weight'][$badge->bid] = array(
      '#type' => 'weight',
      '#default_value' => $weight,
      '#delta' => $delta,
      '#attributes' => array('class' => 'open_badges_userweight_element'),
    );
  }

  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $account->uid,
  );

  $form['submit'] = array('#type' => 'submit', '#value' => t('Submit'));


  return $form;
}

/**
 * Process open_badges_userweight_form form submissions.
 *
 * Update the badge userweights
 */
function open_badges_userweight_form_submit($form, &$form_state) {
  if (isset($form['weight']) && is_array($form['weight'])) {
    foreach (element_children($form['weight']) as $bid) {
      db_query("UPDATE {open_badges_user} SET userweight = %d WHERE bid = %d AND uid = %d",
      $form_state['values'][$bid],
      $bid,
      $form_state['values']['uid']
      );
    }
    drupal_set_message(t('Your badge order has been updated.'));
  }
}

/**
 * Form theming function
 */
function theme_open_badges_userweight_form($form) {
  $output = '';

  //Loop through the array items in the name array to get all the bids for our listed badges
  if (isset($form['name']) && is_array($form['name'])) {
    foreach (element_children($form['name']) as $key) {
      //We only want bids as values of $key
      if (!is_numeric($key)) {
        continue;
      }

      //Create the rows array for the table theme
      $row = array();
      $row[] = drupal_render($form['name'][$key]);
      $row[] = drupal_render($form['badge'][$key]);
      $row[] = drupal_render($form['weight'][$key]);
      //Add the draggable class to this row
      $rows[] = array('data' => $row, 'class' => 'draggable', '#weight' => $form['weight'][$key]['#value']);
    }

    //Sort the rows by their weights
    usort($rows, 'element_sort');

    //Add the submit button
    $row = array();
    $row[] = '';
    $row[] = drupal_render($form['submit']);
    $row[] = '';
    $rows[] = $row;

  }
  else {
    $rows[] = array(array('data' => t('No badges available.'), 'colspan' => '3'));
  }

  //This makes the table draggable
  drupal_add_tabledrag('open_badges_userweight', 'order', 'sibling', 'open_badges_userweight_element');

  //Theme all that we have processed so far into a table
  $output .= theme('table', $form['header']['#value'], $rows, array('id' => 'open_badges_userweight'));

  //Render any remaining form elements
  $output .= drupal_render($form);

  return $output;

}

/**
 * Menu callback; Retrieve a JSON object containing autocomplete suggestions for badges
 */
function open_badges_badge_autocomplete($string = '') {
  $matches = array();

  if (preg_match('/^[^(]+/', $string, $searchstring)) {
    $trimstring = trim($searchstring[0]);
    $result = db_query_range("SELECT * FROM {open_badges_badges} WHERE name LIKE '%%%s%%'", $trimstring, 0, 10);
    while ($badge = db_fetch_object($result)) {
      $matches[$badge->name . ' (' . t('Badge ID') . ' ' . $badge->bid .')'] = check_plain($badge->name) . ' ' . theme('open_badge', $badge);
    }
  }

  drupal_json($matches);
}

/**
 * Validates submissions for textfields that use open_badges_badge_autocomplete strings
 *
 * @param $value
 *   The textfield value
 *
 * @return array($bid,$result)
 * $bid
 *   the bid detected in the string (integer)
 *   for an invalid string, this will be NULL
 * $result
 *   'valid' for a valid string with a real bid
 *   'string' for an incorrectly formatted string
 *   'nobid' for a correctly formatted string with an invalid badge ID
 */
function open_badges_badge_autocomplete_validation($value) {
  if (preg_match('/\('. t('Badge ID') .' (\d+)\)/', $value, $matches)) {
    //The format was correct, but we need to check the bid exists
    if (db_result(db_query('SELECT COUNT(*) FROM {open_badges_badges} b WHERE b.bid=%d', $matches[1]))) {
      //Result found
      return array($matches[1], 'valid');
    }
    else {
      //No result found, return the error code
      return array($matches[1], 'nobid');
    }
  }
  else {
      //Pattern does not match, return the error code
      return array(NULL, 'string');
  }
}


/**
 * Define the page on user/uid/badges/edit.
 */
function open_badges_page($uid) {
  $account = user_load($uid);

  drupal_set_title(t('Edit badges for %user_name', array('%user_name' => $account->name)));

  return drupal_get_form('open_badges_change_form', $account);

}

/**
 * Define the page on user/uid/badges.
 */
function open_badges_userweight_page($uid) {
  $account = user_load($uid);

  drupal_set_title(t('Badges for %user_name', array('%user_name' => $account->name)));

  // Do we have the right to rearrange badges?
  if (variable_get('open_badges_userweight', 0) && ($account->uid == $user->uid || user_access('change badge assignments')) ) {
    // If the setting allows it and we are the badge owner or somebody with permission, yes.
    return drupal_get_form('open_badges_userweight_form', $account);
  }
  else {
    // Otherwise, just list the badges on the page.
    $open_badges = open_badges_get_badges($account->uid, array('nolimit' => TRUE));
    $badges = array();
    foreach ((array)$open_badges as $badge) {
      // dsm($badge, "The badge in open_badges_userweight_page");
      $badges[] = theme('open_badge', $badge, $account);
    }
    if ($badges) {
      $badges = array(theme('item_list', $badges));
      return theme('open_badge_group', $badges);
    }
    else {
      return t('This user is not currently assigned any badges.');
    }
  }

}

/**
 * Form to change badges of a user
 */

//  http://drupal.org/node/1245766

function theme_open_badges_change_form_theme($form) {
  $rows = array();

  // Format the 'add' elements as a table and add
  // that table to the 'add' fieldset
  for ($id = 1; $id <= 5; $id++) {
    $row = array();
    $row[] = drupal_render($form['add']['add'. $id]);
    $row[] = drupal_render($form['add']['issueddate'. $id]);
    $row[] = drupal_render($form['add']['expirationdate'. $id]);
    $row[] = drupal_render($form['add']['evidenceurl'. $id]);
    $rows[] = $row;
  }
  $header = array();
  $attributes = array();
  $addout .= theme('table', $header, $rows, $attributes);
  $form['add']['#children'] = $addout;
  $output .= drupal_render($form);
  return $output;
}

function open_badges_change_form(&$form_state, $account) {
  $form = array();
  $dateformat = 'Y-m-d';
  $datedefault = '0000-00-00';
  
  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $account->uid,
  );
  $form['add'] = array(
    '#type' => 'fieldset',
    '#title' => t('Add Badges'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  for ($i = 1; $i <= 5; $i++) {
    $form['add']['add'. $i] = array(
      '#type' => 'textfield',
      '#title' => t('New Badge !number', array('!number' => $i)),
      '#size' => 40,
      '#maxlength' => 255,
      '#autocomplete_path' => 'open_badges/autocomplete',
    );
    $form['add']['issueddate'. $i] = array(
      '#type' => 'textfield',
      '#default_value' => 'yyyy-mm-dd',
      '#title' => t('Issued Date'),
      '#description' => t('Defaults to \'now\''),
    '#size' => 20,
      '#maxlength' => 30
    );
    $form['add']['expirationdate'. $i] = array(
      '#type' => 'textfield',
      '#default_value' => 'yyyy-mm-dd',
      '#title' => t('Expiration Date'),
      '#description' => t('Defaults to \'never\''),
      '#size' => 20,
      '#maxlength' => 30
    );
    $form['add']['evidenceurl'. $i] = array(
      '#type' => 'textfield',
      '#title' => t('Evidence URL'),
      '#size' => 30,
      '#maxlength' => 255
    );
  }
  if (count($account->badges_all)) {
    $form['remove'] = array(
      '#type' => 'fieldset',
      '#title' => t('Remove Badges'),
      '#weight' => 5,
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    foreach ($account->badges_all as $badge) {
      $form['remove'][$badge->bid] = array(
        '#type' => 'checkbox',
        '#title' => theme('open_badge', $badge, $account),
        '#return_value' => 1,
        '#default_value' => 0,
        '#description' => check_plain($badge->name),
      );
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update Badges'),
    '#weight' => 10,
  );
  
  $form['#theme'] = 'open_badges_change_form_theme';
  return $form;
}

/**
 * Validate open_badges_change_form form submissions.
 */
function open_badges_change_form_validate($form, &$form_state) {
  for ($i = 1; $i <= 5; $i++) {
    if (!empty($form_state['values']['add'. $i])) {
      $validation = open_badges_badge_autocomplete_validation($form_state['values']['add'. $i]);
      switch ($validation[1]) {
        case 'nobid':
          form_set_error('add'. $i, t('@value is not a valid badge ID. Try using the autocomplete function (requires javascript).', array('@value' => $validation[0])));
          break;
        case 'string':
          form_set_error('add'. $i, t('"@value" is not a valid badge. Try using the autocomplete function (requires javascript).', array('@value' => $form_state['values']['add'. $i])));
          break;
      }
    }
    // Verify dates if something other than the default
    if (!empty($form_state['values']['issueddate'. $i]) && $form_state['values']['issueddate'. $i] != 'yyyy-mm-dd') {
      if (!preg_match('/\d{4}\-\d{2}-\d{2}/', $form_state['values']['issueddate'. $i])) {
        form_set_error('issueddate'. $i, t('@value is not in the required \'yyyy-mm-dd\' format.', array('@value' => $form_state['values']['issueddate'. $i])));
      }
    }
    if (!empty($form_state['values']['expirationdate'. $i]) && $form_state['values']['expirationdate'. $i] != 'yyyy-mm-dd') {
      if (!preg_match('/\d{4}\-\d{2}-\d{2}/', $form_state['values']['expirationdate'. $i])) {
        form_set_error('expirationdate'. $i, t('@value is not in the required \'yyyy-mm-dd\' format.', array('@value' => $form_state['values']['expirationdate'. $i])));
      }
    }
  }
}

/**
 * Process open_badges_change_form form submissions.
 *
 * Add the named badge. Remove the checked badges.
 */
function open_badges_change_form_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];

  //Add badges for non-empty fields
  for ($i = 1; $i <= 5; $i++) {
    if (!empty($form_state['values']['add'. $i])) {
      $validation = open_badges_badge_autocomplete_validation($form_state['values']['add'. $i]);
      
      $issueddate = $form_state['values']['issueddate'. $i];
      if (empty($issueddate) || $issueddate == 'yyyy-mm-dd') {
        $issueddate = time();
      } else {
        $issueddate = strtotime($issueddate);
      }
      
      $expirationdate = $form_state['values']['expirationdate'. $i];
      if (empty($expirationdate) || $expirationdate == 'yyyy-mm-dd') {
        $expirationdate = -1;
      } else {
        $expirationdate = strtotime($expirationdate);
      }
      dpm("open_badges_change_form_submit: issueddate: {$issueddate}, expirationdate: {$expirationdate}, evidenceurl: {$form_state['values']['evidenceurl'. $i]}");
      open_badges_user_add_badge($uid, $validation[0], 'user');
    }
  }

  //Remove any checked badges
  $badges_to_go = array();
  foreach ($form_state['values'] as $bid => $value) {
    if (is_numeric($bid) && $value == 1) {
      $badges_to_go[] = $bid;
    }
  }
  if (count($badges_to_go)) {
    foreach ($badges_to_go as $bid) {
      open_badges_user_remove_badge($uid, $bid);
    }
    drupal_set_message(t('!removalcount badge(s) removed.', array('!removalcount' => count($badges_to_go))));
  }

}

/**
 * Assign open badges to a user
 *
 * @param $edit is an array containing badges array
 * @param $uid is the user id
 * @param $quiet suppresses message display
 */
function open_badges_user_save($edit, $uid, $quiet = TRUE) {
  $badges = open_badges_get_badges($uid);

  if (is_array($edit)) {
    // an array of just the checked boxes please
    $newbadges = array();
    foreach ($edit as $bid => $is_selected) {
      if ($is_selected) {
        $newbadges[] = $bid;
      }
    }

    $success = TRUE;

    // what are the added badges?
    $added = array_diff($newbadges, array_keys($badges));

    foreach ($added as $bid) {
      if (!key_exists($bid, $badges)) {
        $success = (boolean) open_badges_user_add_badge($uid, $bid);
      }
    }

    // what are the removed badges?
    $removed = array_diff(array_keys($badges), $newbadges);

    foreach ($removed as $bid) {
      // and user has this badge
      if (key_exists($bid, $badges)) {
        $success = $success && (boolean) open_badges_user_remove_badge($uid, $bid);
      }
    }
    if ($success && !$quiet) {
      drupal_set_message(t('Badges saved.'));
    }
    elseif (!$quiet) {
      drupal_set_message(t('There was a problem saving badges to the database.'), 'error');
    }
  }
}

/**
 * Add a badge to user.
 *
 * @param $uid User ID.
 * @param $bid Badge ID.
 * @param $type Whether set as part of the role, or individually assigned ('user', 'role').
 *
 * @return bool with query success
 */
function open_badges_user_add_badge($uid, $bid, $type = NULL) {
  open_badges_user_remove_badge($uid, $bid, $type);
  return db_query('INSERT INTO {open_badges_user} (uid, bid, type) VALUES (%d, %d, \'%s\')', $uid, $bid, $type);
}


/**
 * remove a badge from user.
 *
 * @param $uid User ID.
 * @param $bid Badge ID.
 * @param $type Whether set as part of the role, or individually assigned ('user', 'role').
 *
 * @return bool with query success
 */
function open_badges_user_remove_badge($uid, $bid, $type = NULL) {
  if (is_null($type)) {
    return db_query('DELETE FROM {open_badges_user} WHERE uid=%d AND bid=%d', $uid, $bid);
  }
  else {
    return db_query('DELETE FROM {open_badges_user} WHERE uid=%d AND bid=%d AND type=\'%s\'', $uid, $bid, $type);
  }
}


/**
 * Return array of open badges where keys are badge ids (bid)
 *   and values are object containing badge info.
 * @param $uid
 *   if $uid is a user id, returns badges for that user.
 *   if $uid is 'all', returns all badges.
 *   if $uid is 'select', returns badges for form_select options.
 * @param $options array of options.
 *   $options['nolimit'] : if TRUE, the limit clause will not be applied for a user
 *   returned values for 'select' are just badge names.
 */
function open_badges_get_badges($uid, $options = array()) {
  static $badges = array(), $past_uid, $past_options;

  // dpm("open_badges_get_badges: uid is '{$uid}'");
  if (isset($badges[$uid])) {
    // dsm($badges[$uid], "open_badges_get_badges: CACHED badges[uid] for uid $uid");
    return $badges[$uid];
  }

  // Do this so we don't return NULL.
  $badges[$uid] = array();

  if (empty($past_uid) || $past_uid !== $uid || $past_options !== $options ) {
    $past_uid = $uid;
    if ($uid == 'all' || $uid == 'select') {
      $sql = db_query('SELECT b.bid, b.weight, b.name, b.image, b.criteria, b.description,
        b.unhideable, b.fixedweight, b.doesnotcounttolimit, b.tid
        FROM {open_badges_badges} b
        ORDER BY b.weight, b.name');
    }
    else {
      $usr = db_result(db_query('SELECT COUNT(uid) FROM {users} WHERE uid = %d AND status = 0', $uid));

      if ($usr && variable_get('open_badges_showblocked', 0)) {
        $sql = db_query('SELECT DISTINCT b.bid, b.weight, b.name, b.image, b.criteria, b.description,
          b.unhideable, b.fixedweight, b.doesnotcounttolimit, u.userweight, b.tid,
          CASE WHEN b.fixedweight = 1 THEN b.weight ELSE COALESCE(u.userweight,b.weight) END coalescedweight
          FROM {open_badges_badges} b
            INNER JOIN {open_badges_user} u ON b.bid = u.bid
            INNER JOIN {open_badges_roles} r ON b.bid = r.bid
          WHERE u.uid = %d AND r.rid = 0
          ORDER BY coalescedweight, b.name',
          $uid);
      }
      else {
        $query = 'SELECT DISTINCT b.bid, b.weight, b.name, b.image, b.criteria, b.description,
          b.unhideable, b.fixedweight, b.doesnotcounttolimit, u.userweight, b.tid,
          CASE WHEN b.fixedweight = 1 THEN b.weight ELSE COALESCE(u.userweight,b.weight) END coalescedweight
          FROM {open_badges_badges} b
            INNER JOIN {open_badges_user} u ON b.bid = u.bid
          WHERE u.uid = %d
          ORDER BY coalescedweight, b.name
          ';
        $sql = db_query($query, $uid);

      }
    }

    // Should we limit the badges returned?
    if (!$options['nolimit'] && variable_get('open_badges_showone', 0)) {
      $limit = variable_get('open_badges_showone', 1);
    }
    else {
      // Set to -1 for no limit.
      $limit = -1;
    }

    while ($badge = db_fetch_object($sql)) {
      // Display the badge if there's no limit or if the badge is unhideable or if we are within our limit.
      if ($limit != 0 || $badge->unhideable == 1) {
        if ($uid == 'select') {
          $badges[$uid][$badge->bid] = $badge->name;
          $badges[$badge->bid]['#attributes'] = array('class' => 'badge ' . _open_badges_class($badge));
        }
        else {
          $badges[$uid][$badge->bid] = $badge;
          $badges[$uid][$badge->bid]->class = 'badge ' . _open_badges_class($badge);
        }
        //Count down our limit, unless the badge doesn't count towards it
        if (!$badge->doesnotcounttolimit) {
          $limit--;
        }
      }
    }
  }

  // dsm($badges[$uid], "open_badges_get_badges: badges[uid] for uid $uid");
  return $badges[$uid];
}


/**
 * Return badge object for given badge id
 */
function open_badges_get_badge($bid) {
  return db_fetch_object(db_query('SELECT * FROM {open_badges_badges} WHERE bid = %d', $bid));
}



function open_badges_delete_form($form_state, $bid) {
  if ($badge = open_badges_get_badge($bid)) {
    $form = array();
    $form['badge'] = array('#value' => theme('open_badge_group', array(theme('open_badge', $badge))));
    $form['bid'] = array('#type' => 'value', '#value' => $bid);
    return confirm_form($form, t('Are you sure you want to delete the badge %name?', array('%name' => $badge->name)), 'admin/user/open_badges');
  }
  form_set_error('', t('This badge does not exist.'));
}

function open_badges_delete_form_submit($form, &$form_state) {
  $bid = $form_state['values']['bid'];
  db_query("DELETE FROM {open_badges_badges} WHERE bid = %d", $bid);
  db_query("DELETE FROM {open_badges_user} WHERE bid = %d", $bid);
  db_query("DELETE FROM {open_badges_roles} WHERE bid = %d", $bid);
  drupal_set_message(t('Badge deleted.'));
  $form_state['redirect'] = 'admin/user/open_badges';
}


/**
 * Returns an array where keys are role ids (rid) and values are the badge ids (bid) associated with that role
 * These values are assigned on admin/user/open_badges/roles
 *
 * @param $rid - if set, return only values for this role
 *
 * @param $options - array of options
 * $options['returnbadges'] - if TRUE, return badge objects, not just bids
 *
 * @return a list of roles
 */
function open_badges_get_roles($rid = NULL, $options = array()) {
  $roles = array();
  $options = array_merge(array('returnbadges' => 'FALSE'), $options);

  if ($rid) {
    $sql = db_query('SELECT ubr.rid, ubr.bid, ubb.name, ubb.image, ubb.weight, ubb.criteria, ubb.tid FROM {open_badges_roles} ubr INNER JOIN {open_badges_badges} ubb ON ubb.bid=ubr.bid WHERE ubr.rid = %d', $rid);
  }
  else {
    $sql = db_query('SELECT ubr.rid, ubr.bid, ubb.name, ubb.image, ubb.weight, ubb.criteria, ubb.tid FROM {open_badges_roles} ubr INNER JOIN {open_badges_badges} ubb ON ubb.bid=ubr.bid', $rid);
  }
  while ($row = db_fetch_object($sql)) {
    if ($options['returnbadges']) {
      $row->image = _open_badges_build_image($row);
      $roles[$row->rid] = $row;
    }
    else {
      $roles[$row->rid] = $row->bid;
    }
  }
  return $roles;
}

/**
 * Save information about roles for open_badges (in settings)
 *
 * @param $roles
 *   An array in the format rid => bid for each role/badge relationship.
 */
function open_badges_save_roles($roles) {
  if (is_array($roles)) {
    // We have to clear out all badges first.
    $success = TRUE;
    db_query('DELETE FROM {open_badges_roles}');
    db_query("DELETE FROM {open_badges_user} WHERE type='role'");

    // Now we loop through the roles and their badges, and assign them to
    // each user accordingly.
    foreach ($roles as $rid => $bid) {
      if ($bid) {
        // First of all, insert all the role and badge relationship
        // into open_badges_roles.
        $success = $success && db_query('INSERT INTO {open_badges_roles} (rid, bid) VALUES (%d, %d)', $rid, $bid);

        // For all of these queries, we LEFT JOIN open_badges_user to check
        // whether there are existing entries for that badge for that user
        // of the "role" type. Otherwise, we get database errors when
        // multiple roles assign the same badge

        // The blocked user "role" (represented as rid 0) has no entry in
        // the users_role table, so it needs its own special query.
        if ($rid == 0) {
          $success = $success && db_query("
            INSERT INTO {open_badges_user} (uid, bid, type)
            SELECT u.uid, %d, 'role'
            FROM {users} u
            LEFT JOIN {open_badges_user} ubu
            ON ubu.uid=u.uid AND ubu.bid=%d AND ubu.type='role'
            WHERE status = 0 AND ubu.uid IS NULL
          ", $bid, $bid);
        }
        // The authenticated user role (represented as rid 2) has no entry
        // in the users_role table, so it needs its own special query.
        elseif ($rid == 2) {
          $success = $success && db_query("
            INSERT INTO {open_badges_user} (uid, bid, type)
            SELECT u.uid, %d, 'role'
            FROM {users} u
            LEFT JOIN {open_badges_user} ubu
            ON ubu.uid=u.uid AND ubu.bid=%d AND ubu.type='role'
            WHERE u.uid > 0 AND ubu.uid IS NULL
          ", $bid, $bid);
        }
        // For all the normal roles, we want to run this query.
        else {
          $success = $success && db_query("
            INSERT INTO {open_badges_user} (uid, bid, type)
            SELECT ur.uid, %d, 'role'
            FROM {users_roles} ur
            LEFT JOIN {open_badges_user} ubu
            ON ubu.uid=ur.uid AND ubu.bid=%d AND ubu.type='role'
            WHERE ur.rid=%d AND ubu.uid IS NULL
          ", $bid, $bid, $rid);
        }
      }
    }
    if ($success) {
      drupal_set_message(t('Roles saved.'));
    }
    else {
      drupal_set_message(t('There was a problem saving roles to the database'));
    }
  }
}

/**
 * Returns HTML representation of open badges for given uid
 *   @param $uid the user id
 *   @param $refresh (FALSE) when TRUE, refreshes the cache for $uid
 *
 *   @return string html representation of openbadges
 */
function open_badges_for_uid($uid, $refresh = FALSE) {
  static $cache;
  if ($uid) {
    if (isset($cache[$uid]) && !$refresh) {
      return $cache[$uid];
    }
    else {
      $open_badges = open_badges_get_badges($uid);
        foreach ((array)$open_badges as $badge) {
        $badges[] = theme('open_badge', $badge, user_load($uid));
      }
      $cache[$uid] = isset($badges) ? theme('open_badge_group', $badges) : '';
      return $cache[$uid];
    }
  }
}

/**
 * Get all open badges for a user.
 * @param $load is array defining criteria for user_load().
 *   The most common use will be:
 *   open_badges_for_user(array('uid'=>123));
 * @return string containing HTML representation of open badges for given user.
 */
function open_badges_for_user($load, $list = FALSE) {
  // @TODO: cache the results to minimize queries.
  $account = user_load($load);

  foreach ((array)$account->badges as $badge) {
    $badges[] = theme('open_badge', $badge, $account);
  }

  if ($list) {
    $badges = array(theme('item_list', $badges));
  }

  if ($badges) {
    return theme('open_badge_group', $badges);
  }
  else {
    // Do we have a "no badges" message?
    if ($nobadges = variable_get('open_badges_nobadges', '')) {
      $nobadges = '<div class="open_badges_no_badges">' . filter_xss_admin(t($nobadges)) . '</div>';
      return theme('open_badge_group', array($nobadges));
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Return html representation of a group of badges
 * $badgeimages is an array of badge image tags from theme_open_badge()
 */
function theme_open_badge_group($badgeimages) {
  //dsm($badgeimages, "The badgeimages passed to theme_open_badge_group");
  if (!empty($badgeimages)) {
    return '<div class="open_badges">'. implode('', $badgeimages) .'</div>';
  }
}

/**
 * Helper function to produce badge image.
 */
function _open_badges_build_image($badge) {
  if (!isset($badge->class)) {
    $badge->class = 'badge ' . _open_badges_class($badge);
  }
  //dpm("_open_badges_build_image: badge class is '{$badge->class}' and image is '{$badge->image}'");
  if (variable_get('open_badges_imagecache', 0)) {
    //dpm("_open_badges_build_image: got variable open_badges_imagecache -- doing theme('imagecache', ...)");
    $image = theme('imagecache', 'open-badges', $badge->image, $badge->name, $badge->name, array('class' => $badge->class));
  }
  else {
    // If we have a full image URL, don't require theme_image to get the size
    // (it only breaks).
    $get_size = valid_url($badge->image, TRUE);
    //dpm("_open_badges_build_image: calling theme 'image' for image '{$badge->image}'");
    $image = theme('image', $badge->image, $badge->name, $badge->name, array('class' => $badge->class), !$get_size);
  }
  // dpm("_open_badges_build_image: returning '{$image}'");
  return $image;
}

/**
 * Return html representation of a badge image
 * (note: theme_image does the check_plaining)
 *
 * XXX Figure out what to do here after removing "href" in favor of "criteria"
 */
function theme_open_badge($badge, $account = NULL) {
  //If we haven't been supplied with a user, use whoever is logged in
  global $user;
  if (is_null($account)) {
    $account = $user;
  }

  if (!isset($badge->class)) {
    $badge->class = 'badge ' . _open_badges_class($badge);
  }
  // dpm("theme_open_badge: badge class is '{$badge->class}'");
  $image = _open_badges_build_image($badge);
  //dpm("The image from _open_badges_build_image is '{$image}'");
  
  $criteria = $badge->criteria;
  // Implement token replacement.
  if (module_exists('token')) {
    $criteria = token_replace($criteria, $type = 'openbadge', $object = $badge);
    $criteria = token_replace($criteria, $type = 'user', $object = $account);
  }

  $pieces = parse_url($criteria);
  $pieces['html'] = TRUE;
  if (isset($pieces['scheme'])) {
    $pieces['path'] = $pieces['scheme'] . '://' . $pieces['host'] . $pieces['path'];
  }

  return l($image, $pieces['path'], $pieces);
}

/**
 *  Implements hook_views_api().
 */
function open_badges_views_api() {
  return array(
    'api' => 2.0,
  );
}

/**
 * Implements hook_action_info().
 */
function open_badges_action_info() {
  return array(
    'open_badges_add_badge_action' => array(
      'description' => t('Add badge'),
      'type' => 'user',
      'configurable' => TRUE,
      'hooks' => array('any' => TRUE),
      ),
    'open_badges_remove_badge_action' => array(
      'description' => t('Remove badge'),
      'type' => 'user',
      'configurable' => TRUE,
      'hooks' => array('any' => TRUE),
    ),
  );
}

/**
 * Implements Drupal action.
 * Adds a badge to the current user.
 */
function open_badges_add_badge_action(&$account, $context = array()) {
  if (isset($account->uid)) {
    $uid = $account->uid;
  }
  elseif (isset($context['uid'])) {
    $uid = $context['uid'];
  }
  else {
    global $user;
    $uid = $user->uid;
  }
  $success = TRUE;
  $badges = open_badges_get_badges('all');

  foreach ($context['badges'] as $bid) {
    $success = (boolean) open_badges_user_add_badge($uid, $bid, 'uid');
    if ($success) {
      watchdog('action', 'Added open badge %badge to user %name.', array('%name' => check_plain($user->name), '%badge' => check_plain($badges[$bid]->name)));
    }
    else {
      watchdog('action', 'Unable to add open badge %badge to user %name.', array('%name' => check_plain($user->name), '%badge' => check_plain($badges[$bid]->name)), WATCHDOG_WARNING);
    }
  }
}

function open_badges_add_badge_action_form($context) {
  $form['badges'] = array('#tree' => TRUE);

  $badges = open_badges_get_badges('all');
  $context['badges'] = is_array($context['badges']) ? $context['badges'] : array();

  foreach ($badges as $badge) {
    $form['badges'][$badge->bid] = array(
      '#type' => 'checkbox',
      '#title' => theme('open_badge', $badge),
      '#return_value' => 1,
      '#default_value' => $context['badges'][$badge->bid],
      '#description' => check_plain($badge->name),
    );
  }

  return $form;
}

function open_badges_add_badge_action_submit($form, $form_state) {
  $badges = array();
  foreach ($form_state['values']['badges'] as $badge => $set) {
    if ($set) {
      $badges[$badge] = $badge;
    }
  }
  return array('badges' => $badges);
}

/**
 * Implementsa Drupal action.
 * Removes a badge to the current user.
 */
function open_badges_remove_badge_action(&$account, $context = array()) {
  if (isset($account->uid)) {
    $uid = $account->uid;
  }
  elseif (isset($context['uid'])) {
    $uid = $context['uid'];
  }
  else {
    global $user;
    $uid = $user->uid;
  }
  $success = TRUE;
  $badges = open_badges_get_badges('all');

  foreach ($context['badges'] as $bid) {
    $success = (boolean) open_badges_user_remove_badge($uid, $bid, 'uid');
    if ($success) {
      watchdog('action', 'Removed open badge %badge from user %name.', array('%name' => check_plain($user->name), '%badge' => check_plain($badges[$bid]->name)));
    }
    else {
      watchdog('action', 'Unable to remove open badge %badge from user %name.', array('%name' => check_plain($user->name), '%badge' => check_plain($badges[$bid]->name)), WATCHDOG_WARNING);
    }
  }
}

function open_badges_remove_badge_action_form($context) {
  $form['badges'] = array('#tree' => TRUE);

  $badges = open_badges_get_badges('all');
  $context['badges'] = is_array($context['badges']) ? $context['badges'] : array();

  foreach ($badges as $badge) {
    $form['badges'][$badge->bid] = array(
      '#type' => 'checkbox',
      '#title' => theme('open_badge', $badge),
      '#return_value' => 1,
      '#default_value' => $context['badges'][$badge->bid],
      '#description' => check_plain($badge->name),
    );
  }

  return $form;
}

function open_badges_remove_badge_action_submit($form, $form_state) {
  $badges = array();
  foreach ($form_state['values']['badges'] as $badge => $set) {
    if ($set) {
      $badges[$badge] = $badge;
    }
  }
  return array('badges' => $badges);
}

/**
 * Implements hook_token_values().
 * @TODO: Add tokens for Submitted By module?
 */
function open_badges_token_values($type, $object = NULL) {
  if ($type == 'openbadge') {
    $badge = $object;
    $tokens['openbadge-name'] = $badge->name;
    $tokens['openbadge-bid'] = $badge->bid;
    return $tokens;
  }
}

/**
 * Implements hook_token_list().
 */
function open_badges_token_list($type = 'all') {
  if ($type == 'openbadge' || $type == 'all') {
    $tokens['openbadge']['openbadge-name'] = t("The badge name");
    $tokens['openbadge']['openbadge-bid'] = t("The badge id number (bid)");
    return $tokens;
  }
}
/**
 * Implements hook_block();
 */
function open_badges_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      return open_badges_block_list();

    case 'view':
      return open_badges_block_view($delta);

    case 'configure':
      return open_badges_block_configure($delta);

    case 'save':
      return open_badges_block_save($delta, $edit);
  }
}

/**
 * Function for open_badges_block(op = 'list').
 */
function open_badges_block_list() {
  return array(
    'current_node' => array('info' => t('Open_Badges: Content Author'), 'cache' => BLOCK_NO_CACHE),
    );
}

/**
 * Function for open_badges_block(op = 'view').
 */
function open_badges_block_view($delta = 0) {
  $block = array();

  switch ($delta) {
    case 'current_node':
      $arg2 = arg(2);
      if (arg(0) == 'node' && is_numeric(arg(1)) && empty($arg2)) {
        $node = menu_get_object();
        if (in_array($node->type, variable_get('open_badges_current_node_types', array()))) {
          $badges = open_badges_for_user(array('uid' => $node->uid));
          $account = user_load(array('uid' => $node->uid));
          $block['title'] = t("@name's Badges", array('@name' => $account->name));
          $block['content'] = $badges;
        }
      }
      break;
  }

  return $block;
}

/**
 * Function for open_badges_block(op = 'configure').
 */
function open_badges_block_configure($delta = 0) {
  $form = array();

  switch ($delta) {
    case 'current_node':
      $form['types'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Show on these content types'),
        '#default_value' => variable_get('open_badges_current_node_types', array()),
        '#options' => node_get_types('names'),
        '#attributes' => array('class' => 'container-inline'),
        );
      break;
  }

  return $form;
}

/**
 * Function for open_badges_block(op = 'save').
 */
function open_badges_block_save($delta = 0, $edit = array()) {
  switch ($delta) {
    case 'current_node':
      variable_set('open_badges_current_node_types', array_filter($edit['types']));
      return;
  }
}

/**
 * Implements hook_cron()
 * UNCOMMENT in order to get Open Badges to work along with Auto Assign Role
 * notes: - this is a quite fast solution in order to solve Auto Assign Role issue
 *        - do not forget to set up your cron
 */
// function open_badges_cron() {
//   $result = db_query('SELECT * FROM {open_badges_roles}');
//
//   $roles = array();
//   while ($o = db_fetch_object($result)) {
//     $roles[$o->rid] = $o->bid;
//   }
//
//   open_badges_save_roles($roles);
// }
